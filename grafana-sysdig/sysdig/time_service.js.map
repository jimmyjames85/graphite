{"version":3,"sources":["../src/time_service.js"],"names":["getRequestTime","timelines","alignments","userTime","console","assert","from","to","fromUs","toUs","timespan","validAlignments","filter","a","max","length","minSampling","sampling","validTimelines","agents","t","alignTo","alignedFrom","Math","trunc","alignedTo","requestTime","min","ApiService","DataService","backend","q","backendSrv","$q","all","send","url","then","responses","data","reject"],"mappings":"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","file":"time_service.js","sourcesContent":["//\n//  Copyright 2018 Draios Inc.\n//\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n//\nimport ApiService from './api_service';\n\nexport default class DataService {\n    static validateTimeWindow(backend, userTime) {\n        const q = backend.backendSrv.$q;\n\n        return q\n            .all([\n                ApiService.send(backend, {\n                    url: `api/history/timelines`\n                }),\n                ApiService.send(backend, {\n                    url: `api/v2/history/timelines/alignments`\n                })\n            ])\n            .then((responses) => {\n                const requestTime = getRequestTime(responses[0].data, responses[1].data, userTime);\n\n                if (requestTime) {\n                    return requestTime;\n                } else {\n                    return q.reject('Unable to validate request time');\n                }\n            });\n    }\n\n    static queryTimelines(backend) {\n        const q = backend.backendSrv.$q;\n\n        return q\n            .all([\n                ApiService.send(backend, {\n                    url: `api/history/timelines`\n                }),\n                ApiService.send(backend, {\n                    url: `api/v2/history/timelines/alignments`\n                })\n            ])\n            .then((responses) => {\n                return {\n                    timelines: responses[0].data,\n                    alignments: responses[1].data\n                };\n            });\n    }\n}\n\nfunction getRequestTime(timelines, alignments, userTime) {\n    console.assert(userTime && userTime.from && userTime.to, 'Argument userTime is missing');\n    if (!(userTime && userTime.from && userTime.to)) {\n        return null;\n    }\n\n    const fromUs = userTime.from * 1000000;\n    const toUs = userTime.to * 1000000;\n    const timespan = toUs - fromUs;\n\n    //\n    // Use alignments that allow the required timespan\n    //\n    const validAlignments = alignments.filter((a) => {\n        return timespan <= a.max * 1000000;\n    });\n\n    if (validAlignments.length === 0) {\n        return null;\n    }\n\n    //\n    // Set min sampling\n    //\n    const minSampling = validAlignments[0].sampling * 1000000;\n\n    //\n    // Filter timelines so that sampling is valid, and the requested time window is partially or\n    // entirely overlapping with a given timeline\n    //\n    const validTimelines = timelines.agents.filter((t) => {\n        return (\n            t.from !== null &&\n            t.to !== null &&\n            minSampling <= t.sampling &&\n            ((fromUs <= t.from && toUs >= t.from) ||\n                (fromUs >= t.from && toUs <= t.to) ||\n                (fromUs <= t.to && toUs >= t.to))\n        );\n    });\n\n    if (validTimelines.length === 0) {\n        return null;\n    }\n\n    //\n    // Align time window with required alignment\n    //\n    const alignTo = validAlignments[0].alignTo * 1000000;\n    const alignedFrom = Math.trunc((Math.trunc(fromUs / alignTo) * alignTo) / 1000000);\n    const alignedTo = Math.trunc((Math.trunc(toUs / alignTo) * alignTo) / 1000000);\n\n    //\n    // Adjust time window according to timeline (might miss first or last portion)\n    //\n    const requestTime = {\n        from: Math.max(alignedFrom, validTimelines[0].from / 1000000),\n        to: Math.min(alignedTo, validTimelines[0].to / 1000000)\n    };\n\n    if (userTime.sampling) {\n        requestTime.sampling = Math.trunc(minSampling / 1000000);\n    }\n\n    return requestTime;\n}\n"]}