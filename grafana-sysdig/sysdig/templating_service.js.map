{"version":3,"sources":["../src/templating_service.js"],"names":["parseFunction","value","functionName","functionPattern","regex","match","options","parseOptions","parseConfiguration","namelessOption","name","pattern","namedOptions","patterns","validate","trim","defaultValue","Number","undefined","to","limit","from","Math","max","min","functionMatch","parsedOptions","namedOptionsPattern","reduce","acc","option","map","join","namedOptionsRegex","RegExp","namedOptionsValidators","d","matches","exec","i","length","forEach","validatedOptions","console","assert","formatValue","parseLabelValue","formatQuotedValue","parsed","labelValue","FormatterService","NULL_TEXT","TemplatingService","query","templateSrv","replace","input","scopedVars","formatTemplateValue","variable","format","validateLabelValuesQuery"],"mappings":"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","file":"templating_service.js","sourcesContent":["import FormatterService from './formatter_service';\n\nexport default class TemplatingService {\n    static validateLabelValuesQuery(query) {\n        const parsed = parseFunction(query, 'label_values');\n        if (parsed) {\n            return parseOptions(parsed.options, 'label_values');\n        } else {\n            return null;\n        }\n    }\n\n    static validateLabelNamesQuery(query) {\n        const parsed = parseFunction(query, 'label_names');\n        if (parsed) {\n            return { pattern: parsed.options, regex: new RegExp(parsed.options) };\n        } else {\n            return null;\n        }\n    }\n\n    static validateMetricsQuery(query) {\n        const parsed = parseFunction(query, 'metrics');\n        if (parsed) {\n            return { pattern: parsed.options, regex: new RegExp(parsed.options) };\n        } else {\n            return null;\n        }\n    }\n\n    static resolveQueryVariables(query, templateSrv) {\n        if (query) {\n            return this.replace(templateSrv, query, null);\n        } else {\n            return null;\n        }\n    }\n\n    static replaceSingleMatch(templateSrv, input, scopedVars) {\n        return templateSrv.replace(input, scopedVars);\n    }\n\n    static replace(templateSrv, input, scopedVars) {\n        return templateSrv.replace(input, scopedVars, (...args) =>\n            this.formatTemplateValue(...args)\n        );\n    }\n\n    static formatTemplateValue(value, variable) {\n        const format = this.validateLabelValuesQuery(variable.query)\n            ? formatQuotedValue\n            : formatValue;\n\n        if (typeof value === 'string') {\n            //\n            // single selection\n            //\n            return format(value);\n        } else {\n            //\n            // \"all\"\n            //\n            return value.map(format).join(', ');\n        }\n    }\n}\n\nfunction parseFunction(value, functionName) {\n    if (value) {\n        const functionPattern = `${functionName}\\\\((?:(.*))\\\\)`;\n        const regex = value.match(`^${functionPattern}$`);\n        if (regex) {\n            const options = regex[1];\n\n            return { options };\n        } else {\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\n\nfunction parseOptions(value, functionName) {\n    switch (functionName) {\n        case 'label_values': {\n            const parseConfiguration = {\n                namelessOption: {\n                    name: 'labelName',\n                    pattern: '([A-Za-z][A-Za-z0-9]*(?:[\\\\._\\\\-:][a-zA-Z0-9]+)*)'\n                },\n                namedOptions: [\n                    {\n                        name: 'filter',\n                        patterns: [`\"([^\"]+)\"`, `'([^']+)'`],\n                        validate: (value) => value.trim(),\n                        defaultValue: null\n                    },\n                    {\n                        name: 'from',\n                        pattern: '(\\\\d+)',\n                        validate: (value) => Number(value),\n                        defaultValue: 0\n                    },\n                    {\n                        name: 'to',\n                        pattern: '(\\\\d+)',\n                        validate: (value) => Number(value),\n                        defaultValue: undefined\n                    },\n                    {\n                        name: 'limit',\n                        pattern: '(\\\\d+)',\n                        validate: (value) => Number(value),\n                        defaultValue: 99\n                    }\n                ],\n                validate: (options) => {\n                    // to overrides limit\n                    if (options.to !== undefined && options.limit !== undefined) {\n                        delete options.limit;\n                    }\n\n                    // to is always derived from from + limit\n                    if (options.limit !== undefined) {\n                        options.to = options.from + options.limit;\n                        delete options.limit;\n                    }\n\n                    // ensure both from+to are always set\n                    if (options.from !== undefined && options.to === undefined) {\n                        options.to = options.from + 99;\n                    } else if (options.to !== undefined && options.from === undefined) {\n                        options.from = options.to - 99;\n                    }\n\n                    // don't let download too much data, but not even too few\n                    if (options.from !== undefined && options.to !== undefined) {\n                        options.from = Math.max(options.from, 0);\n\n                        options.to = Math.min(options.to, options.from + 1000);\n                        options.to = Math.max(options.to, options.from + 1);\n                    }\n\n                    return options;\n                }\n            };\n\n            const functionMatch = value.match(\n                `^${parseConfiguration.namelessOption.pattern}(?:\\\\s*,\\\\s*(.+))?$`\n            );\n\n            if (functionMatch) {\n                const parsedOptions = {};\n                parsedOptions[parseConfiguration.namelessOption.name] = functionMatch[1];\n\n                const namedOptions = functionMatch[2];\n                const namedOptionsPattern = parseConfiguration.namedOptions\n                    .reduce((acc, option) => {\n                        if (option.patterns) {\n                            return [\n                                ...acc,\n                                ...option.patterns.map((pattern) => ({\n                                    name: option.name,\n                                    pattern\n                                }))\n                            ];\n                        } else {\n                            return [...acc, option];\n                        }\n                    }, [])\n                    .map((option) => {\n                        return `(?:(${option.name})=${option.pattern})`;\n                    })\n                    .join('|');\n                const namedOptionsRegex = RegExp(namedOptionsPattern, 'g');\n                const namedOptionsValidators = parseConfiguration.namedOptions.reduce((acc, d) => {\n                    acc[d.name] = d.validate;\n                    return acc;\n                }, {});\n\n                let matches;\n                while ((matches = namedOptionsRegex.exec(namedOptions)) !== null) {\n                    for (let i = 1; i < matches.length; i = i + 2) {\n                        if (matches[i]) {\n                            parsedOptions[matches[i]] = namedOptionsValidators[matches[i]](\n                                matches[i + 1]\n                            );\n                        }\n                    }\n                }\n\n                parseConfiguration.namedOptions.forEach((option) => {\n                    if (parsedOptions[option.name] === undefined) {\n                        parsedOptions[option.name] = option.defaultValue;\n                    }\n                });\n\n                const validatedOptions = parseConfiguration.validate(parsedOptions);\n\n                return validatedOptions;\n            } else {\n                return null;\n            }\n        }\n\n        default:\n            console.assert(\n                false,\n                'Options are not supported for any variable function other than \"label_values\"'\n            );\n            return null;\n    }\n}\n\nfunction formatValue(value) {\n    return parseLabelValue(value);\n}\n\nfunction formatQuotedValue(value) {\n    const parsed = parseLabelValue(value);\n\n    // encapsulate value within double-quotes to make the output valid with both strings and null values\n    // also, null values must be returned as \"null\" strings\n    return parsed ? `\"${parsed}\"` : `${parsed}`;\n}\n\nfunction parseLabelValue(labelValue) {\n    return labelValue === FormatterService.NULL_TEXT ? null : labelValue;\n}\n"]}