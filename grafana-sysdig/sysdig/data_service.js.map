{"version":3,"sources":["../src/data_service.js"],"names":["getBatchId","userTime","from","to","sampling","getRequests","options","requestTime","targets","map","target","getRequest","format","type","time","getTime","metrics","getMetrics","sort","getSort","paging","getPaging","scope","filter","group","aggregations","v0","timeAggregation","groupAggregations","groupAggregation","by","getGroupBy","configuration","groups","isSingleDataPoint","segmentBy","forEach","i","k0","sortDirection","isTabularFormat","push","k1","pageLimit","groupBy","metric","value","parseResponses","response","isSingleTarget","length","data","reduce","acc","d","keys","slice","t","segmentNames","segment","FormatterService","formatLabelValue","join","undefined","datapoints","key","Object","values","a","b","localeCompare","error","errors","failures","targetsDataset","segments","tabularDataset","assign","columns","text","rows","referenceRow","referenceData","_","flatten","ApiService","TimeService","fetchQueue","DataService","backend","query","queue","setupTokenRequestQueue","apiToken","batch","setupDataBatchQueue","promise","backendSrv","$q","defer","requests","scheduleFetchFn","debounce","scheduleFetch","bind","batchId","queues","fetchBatch","q","validateTimeWindow","then","apiRequests","item","maxRequestCountPerChunk","chunks","request","all","chunk","send","url","method","responses","targetResponseCount","targetResponses","parseResult","failedResults","reject","message","reason","resolve"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAqNA,aAASA,UAAT,CAAoBC,QAApB,EAA8B;AAC1B,eAAUA,SAASC,IAAnB,WAA6BD,SAASE,EAAtC,WAA8CF,SAASG,QAAvD;AACH;;AAED,aAASC,WAAT,CAAqBC,OAArB,EAA8BC,WAA9B,EAA2C;AACvC,eAAOD,QAAQE,OAAR,CAAgBC,GAAhB,CAAoB,UAACC,MAAD;AAAA,mBAAYC,WAAWD,MAAX,EAAmBH,WAAnB,CAAZ;AAAA,SAApB,CAAP;AACH;;AAED,aAASI,UAAT,CAAoBD,MAApB,EAA4BH,WAA5B,EAAyC;AACrC,YAAIA,WAAJ,EAAiB;AACb,mBAAO;AACHK,wBAAQ;AACJC,0BAAM;AADF,iBADL;AAIHC,sBAAMC,SAJH;AAKHC,yBAASC,YALN;AAMHC,sBAAMC,SANH;AAOHC,wBAAQC,WAPL;AAQHC,uBAAOZ,OAAOa,MARX;AASHC,uBAAO;AACHC,kCAAc;AACVC,4BAAIhB,OAAOiB;AADD,qBADX;AAIHC,uCAAmB;AACfF,4BAAIhB,OAAOmB;AADI,qBAJhB;AAOHC,wBAAIC,YAPD;AAQHC,mCAAe;AACXC,gCAAQ;AADG;AARZ;AATJ,aAAP;AAsBH,SAvBD,MAuBO;AACH,mBAAO,IAAP;AACH;;AAED,iBAASlB,OAAT,GAAmB;AACf,mBAAO;AACHb,sBAAMK,YAAYL,IAAZ,GAAmB,OADtB;AAEHC,oBAAII,YAAYJ,EAAZ,GAAiB,OAFlB;AAGHC,0BACI,CAACM,OAAOwB,iBAAP,GACK3B,YAAYJ,EAAZ,GAAiBI,YAAYL,IADlC,GAEKK,YAAYH,QAFlB,IAE8B;AAN/B,aAAP;AAQH;AACD,iBAASa,UAAT,GAAsB;AAClB,gBAAIP,OAAOwB,iBAAX,EAA8B;AAC1B,oBAAMlB,UAAU;AACZU,wBAAIhB,OAAOA;AADC,iBAAhB;;AAIA,oBAAIA,OAAOyB,SAAX,EAAsB;AAClBzB,2BAAOyB,SAAP,CAAiBC,OAAjB,CAAyB,UAACD,SAAD,EAAYE,CAAZ,EAAkB;AACvCrB,sCAAYqB,CAAZ,IAAmBF,SAAnB;AACH,qBAFD;AAGH;;AAED,uBAAOnB,OAAP;AACH,aAZD,MAYO;AACH,oBAAMA,WAAU;AACZsB,wBAAI,WADQ;AAEZZ,wBAAIhB,OAAOA;AAFC,iBAAhB;;AAKA,oBAAIA,OAAOyB,SAAX,EAAsB;AAClBzB,2BAAOyB,SAAP,CAAiBC,OAAjB,CAAyB,UAACD,SAAD,EAAYE,CAAZ,EAAkB;AACvCrB,wCAAYqB,IAAI,CAAhB,KAAuBF,SAAvB;AACH,qBAFD;AAGH;;AAED,uBAAOnB,QAAP;AACH;AACJ;;AAED,iBAASG,OAAT,GAAmB;AACf,gBAAMoB,gBAAgB7B,OAAO6B,aAAP,IAAwB,MAA9C;;AAEA,gBAAIrB,aAAJ;;AAEA,gBAAIR,OAAO8B,eAAP,KAA2B,KAA/B,EAAsC;AAClCtB,uBAAO,CAAC,EAAEQ,IAAIa,aAAN,EAAD,EAAwB,EAAED,IAAIC,aAAN,EAAxB,CAAP;;AAEA,oBAAI7B,OAAOyB,SAAX,EAAsB;AAClBjB,yBAAKuB,IAAL,CAAU,EAAEC,IAAIH,aAAN,EAAV;AACH;AACJ,aAND,MAMO;AACH;AACArB,uBAAO,CAAC,EAAEoB,IAAIC,aAAN,EAAD,CAAP;AACH;;AAED,mBAAOrB,IAAP;AACH;;AAED,iBAASG,SAAT,GAAqB;AACjB,mBAAO;AACHnB,sBAAM,CADH;AAEHC,oBAAI,CAACO,OAAOiC,SAAP,IAAoB,EAArB,IAA2B;AAF5B,aAAP;AAIH;;AAED,iBAASZ,UAAT,GAAsB;AAClB,gBAAIrB,OAAOwB,iBAAX,EAA8B;AAC1B,oBAAMU,UAAU,EAAhB;;AAEA,oBAAIlC,OAAOyB,SAAX,EAAsB;AAClBzB,2BAAOyB,SAAP,CAAiBC,OAAjB,CAAyB,UAACD,SAAD,EAAYE,CAAZ,EAAkB;AACvCO,gCAAQH,IAAR,CAAa;AACTI,0CAAYR;AADH,yBAAb;AAGH,qBAJD;AAKH;;AAED,uBAAOO,OAAP;AACH,aAZD,MAYO;AACH,oBAAMA,WAAU,CACZ;AACIC,4BAAQ,IADZ;AAEIC,2BAAOvC,YAAYH,QAAZ,GAAuB;AAFlC,iBADY,CAAhB;;AAOA,oBAAIM,OAAOyB,SAAX,EAAsB;AAClBzB,2BAAOyB,SAAP,CAAiBC,OAAjB,CAAyB,UAACD,SAAD,EAAYE,CAAZ,EAAkB;AACvCO,iCAAQH,IAAR,CAAa;AACTI,2CAAYR,IAAI,CAAhB;AADS,yBAAb;AAGH,qBAJD;AAKH;;AAED,uBAAOO,QAAP;AACH;AACJ;AACJ;;AAED,aAASG,cAAT,CAAwBzC,OAAxB,EAAiC0C,QAAjC,EAA2C;AACvC,YAAMR,kBAAkBlC,QAAQE,OAAR,CAAgB,CAAhB,EAAmBgC,eAA3C;AACA,YAAMS,iBAAiB3C,QAAQE,OAAR,CAAgB0C,MAAhB,KAA2B,CAAlD;AACA,YAAMC,OAAO7C,QAAQE,OAAR,CAAgBC,GAAhB,CAAoB,UAACC,MAAD,EAAS2B,CAAT,EAAe;AAC5C,gBAAMH,oBAAoBxB,OAAOwB,iBAAjC;;AAEA,gBAAIc,SAASX,CAAT,EAAYc,IAAhB,EAAsB;AAClB,oBAAM1C,MAAMuC,SAASX,CAAT,EAAYc,IAAZ,CAAiBC,MAAjB,CAAwB,UAACC,GAAD,EAAMC,CAAN,EAAY;AAC5C,wBAAMC,OAAOP,SAASX,CAAT,EAAYb,KAAZ,CAAkBM,EAAlB,CACRrB,GADQ,CACJ,UAACe,KAAD;AAAA,+BAAWA,MAAM,QAAN,CAAX;AAAA,qBADI;AAET;AAFS,qBAGRgC,KAHQ,CAGFtB,oBAAoB,CAApB,GAAwB,CAHtB,CAAb;;AAKA,wBAAIuB,UAAJ;AACA,wBAAI/C,OAAOyB,SAAX,EAAsB;AAClB,4BAAMuB,eAAeH,KAChB9C,GADgB,CACZ,UAACkD,OAAD;AAAA,mCAAaC,iBAAiBC,gBAAjB,CAAkCP,EAAEK,OAAF,CAAlC,CAAb;AAAA,yBADY,EAEhBG,IAFgB,CAEX,KAFW,CAArB;;AAIA,4BAAItB,mBAAmBS,cAAvB,EAAuC;AACnCQ,gCAAIC,YAAJ;AACH,yBAFD,MAEO;AACHD,gCAAOG,iBAAiBC,gBAAjB,CAAkCnD,OAAOA,MAAzC,CAAP,UAA4DgD,YAA5D;AACH;AACJ,qBAVD,MAUO;AACHD,4BAAIG,iBAAiBC,gBAAjB,CAAkCnD,OAAOA,MAAzC,CAAJ;AACH;;AAED,wBAAI2C,IAAII,CAAJ,MAAWM,SAAf,EAA0B;AACtBV,4BAAII,CAAJ,IAAS;AACL/C,oCAAQ+C,CADH;AAELO,wCAAY;AAFP,yBAAT;AAIH;;AAED,wBAAIxB,eAAJ,EAAqB;AACjBa,4BAAII,CAAJ,EAAOO,UAAP,CAAkBvB,IAAlB,8BACOc,KAAK9C,GAAL,CAAS,UAACwD,GAAD;AAAA,mCAASX,EAAEW,GAAF,CAAT;AAAA,yBAAT,CADP,IAEIX,EAAE5B,EAFN,EAGIsB,SAASX,CAAT,EAAYvB,IAAZ,CAAiBZ,IAHrB;AAKH,qBAND,MAMO,IAAIgC,iBAAJ,EAAuB;AAC1BmB,4BAAII,CAAJ,EAAOO,UAAP,CAAkBvB,IAAlB,CAAuB,CAACa,EAAE5B,EAAH,EAAOsB,SAASX,CAAT,EAAYvB,IAAZ,CAAiBZ,IAAxB,CAAvB;AACH,qBAFM,MAEA;AACHmD,4BAAII,CAAJ,EAAOO,UAAP,CAAkBvB,IAAlB,CAAuB,CAACa,EAAE5B,EAAH,EAAO4B,EAAEhB,EAAF,GAAO,IAAd,CAAvB;AACH;;AAED,2BAAOe,GAAP;AACH,iBAzCW,EAyCT,EAzCS,CAAZ;;AA2CA,oBAAInB,iBAAJ,EAAuB;AACnB,2BAAOgC,OAAOC,MAAP,CAAc1D,GAAd,EAAmBS,IAAnB,CAAwB,UAACkD,CAAD,EAAIC,CAAJ,EAAU;AACrC,4BAAID,EAAEJ,UAAF,CAAa,CAAb,EAAgB,CAAhB,MAAuBK,EAAEL,UAAF,CAAa,CAAb,EAAgB,CAAhB,CAA3B,EAA+C;AAC3C,mCAAOI,EAAE1D,MAAF,CAAS4D,aAAT,CAAuBD,EAAE3D,MAAzB,CAAP;AACH,yBAFD,MAEO;AACH,gCAAIA,OAAO6B,aAAP,KAAyB,MAA7B,EAAqC;AACjC,uCAAO8B,EAAEL,UAAF,CAAa,CAAb,EAAgB,CAAhB,IAAqBI,EAAEJ,UAAF,CAAa,CAAb,EAAgB,CAAhB,CAA5B;AACH,6BAFD,MAEO;AACH,uCAAOI,EAAEJ,UAAF,CAAa,CAAb,EAAgB,CAAhB,IAAqBK,EAAEL,UAAF,CAAa,CAAb,EAAgB,CAAhB,CAA5B;AACH;AACJ;AACJ,qBAVM,CAAP;AAWH,iBAZD,MAYO;AACH,2BAAOE,OAAOC,MAAP,CAAc1D,GAAd,EAAmBS,IAAnB,CAAwB,UAACkD,CAAD,EAAIC,CAAJ;AAAA,+BAAUD,EAAE1D,MAAF,CAAS4D,aAAT,CAAuBD,EAAE3D,MAAzB,CAAV;AAAA,qBAAxB,CAAP;AACH;AACJ,aA3DD,MA2DO;AACH,uBAAO;AACHA,4BAAQA,OAAOA,MADZ;AAEH6D,2BAAOvB,SAASX,CAAT,EAAYmC,MAAZ,CAAmB,CAAnB;AAFJ,iBAAP;AAIH;AACJ,SApEY,CAAb;;AAsEA,YAAIhC,mBAAmBW,KAAKD,MAAL,GAAc,CAArC,EAAwC;AACpC,gBAAMuB,WAAWtB,KAAK5B,MAAL,CAAY,UAAC+B,CAAD;AAAA,uBAAOA,EAAEiB,KAAT;AAAA,aAAZ,CAAjB;AACA,gBAAIE,SAASvB,MAAT,GAAkB,CAAtB,EAAyB;AACrB,uBAAO,EAAEC,MAAMsB,QAAR,EAAP;AACH;;AAED,gBAAMC,iBAAiBvB,KAAK,CAAL,CAAvB;AACA,gBAAMwB,WAAWrE,QAAQE,OAAR,CAAgB,CAAhB,EAAmB2B,SAApC;AACA,gBAAMnB,UAAUV,QAAQE,OAAR,CAAgBC,GAAhB,CAAoB,UAACC,MAAD;AAAA,uBAAYA,OAAOA,MAAnB;AAAA,aAApB,CAAhB;;AAEA,gBAAMkE,iBAAiBV,OAAOW,MAAP,CAAc,EAAd,EAAkBH,cAAlB,EAAkC;AACrD7D,sBAAM,OAD+C;AAErDiE,sDACOH,SAASlE,GAAT,CAAa,UAAC0B,SAAD;AAAA,2BAAgB,EAAE4C,MAAM5C,SAAR,EAAhB;AAAA,iBAAb,CADP,sBAEOnB,QAAQP,GAAR,CAAY,UAACoC,MAAD;AAAA,2BAAa,EAAEkC,MAAMlC,MAAR,EAAb;AAAA,iBAAZ,CAFP,EAFqD;AAMrDmC,sBAAMN,eAAejE,GAAf,CAAmB,UAACwE,YAAD,EAAe5C,CAAf,EAAqB;AAC1C,wBAAM6C,gBAAgBD,aAAajB,UAAb,CAAwB,CAAxB,CAAtB;;AAEA,wDACOkB,cAAc1B,KAAd,CAAoB,CAApB,EAAuBmB,SAASzB,MAAhC,CADP,IAEIgC,cAAcP,SAASzB,MAAvB,CAFJ,sBAGOC,KAAKK,KAAL,CAAW,CAAX,EAAc/C,GAAd,CAAkB,UAAC6C,CAAD,EAAO;AACxB,4BAAIA,EAAEjB,CAAF,EAAK3B,MAAL,KAAgBuE,aAAavE,MAAjC,EAAyC;AACrC,mCAAO4C,EAAEjB,CAAF,EAAK2B,UAAL,CAAgB,CAAhB,EAAmBW,SAASzB,MAA5B,CAAP;AACH,yBAFD,MAEO;AACH;AACA,mCAAO,IAAP;AACH;AACJ,qBAPE,CAHP;AAYH,iBAfK;AAN+C,aAAlC,CAAvB;;AAwBA,mBAAO;AACHC,sBAAM,CAACe,OAAOW,MAAP,CAAc,EAAd,EAAkB1B,KAAK,CAAL,CAAlB,EAA2ByB,cAA3B,CAAD;AADH,aAAP;AAGH,SArCD,MAqCO;AACH,mBAAO;AACHzB,sBAAMgC,EAAEC,OAAF,CAAUjC,IAAV;AADH,aAAP;AAGH;AACJ;;;AAhcMgC,a;;AACAE,sB;;AACAC,uB;;AACA1B,4B;;;;;;;;;;;;;;;;;;;;;AAEH2B,sB;;AAEiBC,uB;;;;;;;0CACJC,O,EAASC,K,EAAOzF,Q,EAAU;AACnC,4BAAM0F,QAAQ,KAAKC,sBAAL,CAA4BH,QAAQI,QAApC,CAAd;AACA,4BAAMC,QAAQ,KAAKC,mBAAL,CAAyBJ,KAAzB,EAAgCF,OAAhC,EAAyCxF,QAAzC,CAAd;;AAEA,4BAAM+F,UAAUP,QAAQQ,UAAR,CAAmBC,EAAnB,CAAsBC,KAAtB,EAAhB;AACAL,8BAAMM,QAAN,CAAe3D,IAAf,CAAoB;AAChBiD,wCADgB;AAEhBM;AAFgB,yBAApB;;AAKA;AACA;AACA;AACA;AACA,4BAAMK,kBAAkBlB,EAAEmB,QAAF,CAAW,KAAKC,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAAX,EAA0C,CAA1C,CAAxB;AACAH;;AAEA,+BAAOL,QAAQA,OAAf;AACH;;;wDAE0BL,K,EAAOF,O,EAASxF,Q,EAAU;AACjD,4BAAMwG,UAAUzG,WAAWC,QAAX,CAAhB;;AAEA,4BAAI0F,MAAMc,OAAN,MAAmB1C,SAAvB,EAAkC;AAC9B4B,kCAAMc,OAAN,IAAiB;AACbhB,gDADa;AAEbxF,kDAFa;AAGbmG,0CAAU;AAHG,6BAAjB;AAKH;;AAED,+BAAOT,MAAMc,OAAN,CAAP;AACH;;;oDAEsB;AAAA;;AACnB,4BAAMC,SAASxC,OAAOC,MAAP,CAAcoB,UAAd,CAAf;;AAEA;AACAA,qCAAa,EAAb;;AAEAmB,+BAAOtE,OAAP,CAAe,UAACuD,KAAD,EAAW;AACtBzB,mCAAOC,MAAP,CAAcwB,KAAd,EAAqBvD,OAArB,CAA6B,UAAC0D,KAAD;AAAA,uCAAW,MAAKa,UAAL,CAAgBb,KAAhB,CAAX;AAAA,6BAA7B;AACH,yBAFD;AAGH;;;+CAEiBA,K,EAAO;AACrB,4BAAMc,IAAId,MAAML,OAAN,CAAcQ,UAAd,CAAyBC,EAAnC;;AAEAZ,oCAAYuB,kBAAZ,CAA+Bf,MAAML,OAArC,EAA8CK,MAAM7F,QAApD,EACK6G,IADL,CACU,UAACvG,WAAD,EAAiB;AACnB;AACA;AACA;AACA,gCAAMwG,cAAcjB,MAAMM,QAAN,CAAehD,MAAf,CAAsB,UAACC,GAAD,EAAM2D,IAAN,EAAe;AACrD,oEAAW3D,GAAX,sBAAmBhD,YAAY2G,KAAKtB,KAAjB,EAAwBnF,WAAxB,CAAnB;AACH,6BAFmB,EAEjB,EAFiB,CAApB;;AAIA;AACA;AACA;AACA,gCAAM0G,0BAA0B,EAAhC;AACA,gCAAMC,SAASH,YAAY3D,MAAZ,CAAmB,UAACC,GAAD,EAAM8D,OAAN,EAAkB;AAChD,oCACI9D,IAAIH,MAAJ,KAAe,CAAf,IACAG,IAAIA,IAAIH,MAAJ,GAAa,CAAjB,EAAoBA,MAApB,KAA+B+D,uBAFnC,EAGE;AACE5D,wCAAIZ,IAAJ,CAAS,CAAC0E,OAAD,CAAT;AACH,iCALD,MAKO;AACH9D,wCAAIA,IAAIH,MAAJ,GAAa,CAAjB,EAAoBT,IAApB,CAAyB0E,OAAzB;AACH;;AAED,uCAAO9D,GAAP;AACH,6BAXc,EAWZ,EAXY,CAAf;;AAaA,gCAAI9C,WAAJ,EAAiB;AACb;AACA;AACA;AACA,uCAAOqG,EAAEQ,GAAF,CACHF,OAAOzG,GAAP,CAAW,UAAC4G,KAAD;AAAA,2CACPhC,WAAWiC,IAAX,CAAgBxB,MAAML,OAAtB,EAA+B;AAC3B8B,6DAD2B;AAE3BpE,8CAAM,EAAEiD,UAAUiB,KAAZ,EAFqB;AAG3BG,gDAAQ;AAHmB,qCAA/B,CADO;AAAA,iCAAX,CADG,CAAP;AASH,6BAbD,MAaO;AACH;AACA;AACA;AACA,uCAAON,OAAOzG,GAAP,CAAW,UAAC4G,KAAD;AAAA,2CAAY;AAC1BlE,8CAAM;AACFsE,uDAAWJ,MAAM5G,GAAN,CAAU;AAAA,uDAAO,EAAE0C,MAAM,EAAR,EAAP;AAAA,6CAAV;AADT;AADoB,qCAAZ;AAAA,iCAAX,CAAP;AAKH;AACJ,yBAjDL,EAkDK2D,IAlDL,CAmDQ,UAACI,MAAD,EAAY;AACR;AACA;AACA;AACA,gCAAIO,YAAYP,OAAO9D,MAAP,CACZ,UAACC,GAAD,EAAMgE,KAAN;AAAA,oEAAoBhE,GAApB,sBAA4BgE,MAAMlE,IAAN,CAAWsE,SAAvC;AAAA,6BADY,EAEZ,EAFY,CAAhB;;AAKA;AACA;AACA;AACA3B,kCAAMM,QAAN,CAAehE,OAAf,CAAuB,UAAC4E,IAAD,EAAU;AAC7B,oCAAMU,sBAAsBV,KAAKtB,KAAL,CAAWlF,OAAX,CAAmB0C,MAA/C;AACA,oCAAMyE,kBAAkBF,UAAUjE,KAAV,CAAgB,CAAhB,EAAmBkE,mBAAnB,CAAxB;;AAEA,oCAAME,cAAc7E,eAAeiE,KAAKtB,KAApB,EAA2BiC,eAA3B,CAApB;AACA,oCAAME,gBAAgBD,YAAYzE,IAAZ,CAAiB5B,MAAjB,CAAwB,UAAC+B,CAAD;AAAA,2CAAOA,EAAEiB,KAAT;AAAA,iCAAxB,CAAtB;AACA,oCACIqD,YAAYzE,IAAZ,CAAiBD,MAAjB,GAA0B,CAA1B,IACA2E,cAAc3E,MAAd,KAAyB0E,YAAYzE,IAAZ,CAAiBD,MAF9C,EAGE;AACE,wCAAMqB,QAAQsD,cAAc,CAAd,EAAiBtD,KAA/B;AACAyC,yCAAKhB,OAAL,CAAa8B,MAAb,CAAoB;AAChBC,iDAAYxD,MAAMyD,MAAlB,UAA6BzD,MAAMwD,OAAnC;AADgB,qCAApB;AAGH,iCARD,MAQO;AACHf,yCAAKhB,OAAL,CAAaiC,OAAb,CAAqBL,WAArB;AACH;;AAEDH,4CAAYA,UAAUjE,KAAV,CAAgBkE,mBAAhB,CAAZ;AACH,6BAnBD;AAoBH,yBAnFT,EAoFQ,UAACnD,KAAD,EAAW;AACP;AACAuB,kCAAMM,QAAN,CAAehE,OAAf,CAAuB,UAAC+E,OAAD,EAAa;AAChCA,wCAAQnB,OAAR,CAAgB8B,MAAhB,CAAuBvD,KAAvB;AACH,6BAFD;AAGH,yBAzFT;;AA4FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH;;;2DAE6BsB,Q,EAAU;AACpC,4BAAIN,eAAexB,SAAnB,EAA8B;AAC1BwB,yCAAa,EAAb;AACH;;AAED,4BAAIA,WAAWM,QAAX,MAAyB9B,SAA7B,EAAwC;AACpCwB,uCAAWM,QAAX,IAAuB,EAAvB;AACH;;AAED,+BAAON,WAAWM,QAAX,CAAP;AACH;;;;;;+BA5LgBL,W","file":"data_service.js","sourcesContent":["//\n//  Copyright 2018 Draios Inc.\n//\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n//\nimport _ from 'lodash';\nimport ApiService from './api_service';\nimport TimeService from './time_service';\nimport FormatterService from './formatter_service';\n\nlet fetchQueue;\n\nexport default class DataService {\n    static fetch(backend, query, userTime) {\n        const queue = this.setupTokenRequestQueue(backend.apiToken);\n        const batch = this.setupDataBatchQueue(queue, backend, userTime);\n\n        const promise = backend.backendSrv.$q.defer();\n        batch.requests.push({\n            query,\n            promise\n        });\n\n        //\n        // Debounce fetch so that all panels' requests can be batched together\n        // Note that this function will be called synchronously once per panel\n        //\n        const scheduleFetchFn = _.debounce(this.scheduleFetch.bind(this), 0);\n        scheduleFetchFn();\n\n        return promise.promise;\n    }\n\n    static setupDataBatchQueue(queue, backend, userTime) {\n        const batchId = getBatchId(userTime);\n\n        if (queue[batchId] === undefined) {\n            queue[batchId] = {\n                backend,\n                userTime,\n                requests: []\n            };\n        }\n\n        return queue[batchId];\n    }\n\n    static scheduleFetch() {\n        const queues = Object.values(fetchQueue);\n\n        // clear queue, requests will be now processed\n        fetchQueue = {};\n\n        queues.forEach((queue) => {\n            Object.values(queue).forEach((batch) => this.fetchBatch(batch));\n        });\n    }\n\n    static fetchBatch(batch) {\n        const q = batch.backend.backendSrv.$q;\n\n        TimeService.validateTimeWindow(batch.backend, batch.userTime)\n            .then((requestTime) => {\n                //\n                // get list of data requests to batch\n                //\n                const apiRequests = batch.requests.reduce((acc, item) => {\n                    return [...acc, ...getRequests(item.query, requestTime)];\n                }, []);\n\n                //\n                // break list into 20-request chunks\n                //\n                const maxRequestCountPerChunk = 20;\n                const chunks = apiRequests.reduce((acc, request) => {\n                    if (\n                        acc.length === 0 ||\n                        acc[acc.length - 1].length === maxRequestCountPerChunk\n                    ) {\n                        acc.push([request]);\n                    } else {\n                        acc[acc.length - 1].push(request);\n                    }\n\n                    return acc;\n                }, []);\n\n                if (requestTime) {\n                    //\n                    // send all batch requests\n                    //\n                    return q.all(\n                        chunks.map((chunk) =>\n                            ApiService.send(batch.backend, {\n                                url: `api/data/batch`,\n                                data: { requests: chunk },\n                                method: 'POST'\n                            })\n                        )\n                    );\n                } else {\n                    //\n                    // pretend the backend returned all empty datasets\n                    //\n                    return chunks.map((chunk) => ({\n                        data: {\n                            responses: chunk.map(() => ({ data: [] }))\n                        }\n                    }));\n                }\n            })\n            .then(\n                (chunks) => {\n                    //\n                    // flatten responses\n                    //\n                    let responses = chunks.reduce(\n                        (acc, chunk) => [...acc, ...chunk.data.responses],\n                        []\n                    );\n\n                    //\n                    // process and resolve each query with its response(s)\n                    //\n                    batch.requests.forEach((item) => {\n                        const targetResponseCount = item.query.targets.length;\n                        const targetResponses = responses.slice(0, targetResponseCount);\n\n                        const parseResult = parseResponses(item.query, targetResponses);\n                        const failedResults = parseResult.data.filter((d) => d.error);\n                        if (\n                            parseResult.data.length > 0 &&\n                            failedResults.length === parseResult.data.length\n                        ) {\n                            const error = failedResults[0].error;\n                            item.promise.reject({\n                                message: `${error.reason} (${error.message})`\n                            });\n                        } else {\n                            item.promise.resolve(parseResult);\n                        }\n\n                        responses = responses.slice(targetResponseCount);\n                    });\n                },\n                (error) => {\n                    // time window not available\n                    batch.requests.forEach((request) => {\n                        request.promise.reject(error);\n                    });\n                }\n            );\n\n        //\n        // TODO\n        //\n        // 1. Handle 200 OK with error response\n        // {\n        //   \"responses\" : [ {\n        //     \"errors\" : [ {\n        //       \"reason\" : \"Metric not found\",\n        //       \"message\" : \"'sysdigcloud-backend.events_dropped_total' is not a Sysdig Cloud metric\",\n        //       \"field\" : \"metrics\",\n        //       \"rejectedValue\" : [ {\n        //         \"groupAggregation\" : null,\n        //         \"alias\" : \"k0\",\n        //         \"aggregations\" : {\n        //           \"time\" : null,\n        //           \"group\" : null\n        //         },\n        //         \"timeAggregation\" : null,\n        //         \"metric\" : \"timestamp\"\n        //       }, {\n        //         \"groupAggregation\" : \"concat\",\n        //         \"alias\" : \"v0\",\n        //         \"aggregations\" : {\n        //           \"time\" : \"concat\",\n        //           \"group\" : \"concat\"\n        //         },\n        //         \"timeAggregation\" : \"concat\",\n        //         \"metric\" : \"sysdigcloud-backend.events_dropped_total\"\n        //       } ]\n        //     } ]\n        //   } ]\n        // }\n        //\n        // 2. Handle error like 500 Internal Server Error\n        //\n    }\n\n    static setupTokenRequestQueue(apiToken) {\n        if (fetchQueue === undefined) {\n            fetchQueue = {};\n        }\n\n        if (fetchQueue[apiToken] === undefined) {\n            fetchQueue[apiToken] = {};\n        }\n\n        return fetchQueue[apiToken];\n    }\n}\n\nfunction getBatchId(userTime) {\n    return `${userTime.from} - ${userTime.to} - ${userTime.sampling}`;\n}\n\nfunction getRequests(options, requestTime) {\n    return options.targets.map((target) => getRequest(target, requestTime));\n}\n\nfunction getRequest(target, requestTime) {\n    if (requestTime) {\n        return {\n            format: {\n                type: 'data'\n            },\n            time: getTime(),\n            metrics: getMetrics(),\n            sort: getSort(),\n            paging: getPaging(),\n            scope: target.filter,\n            group: {\n                aggregations: {\n                    v0: target.timeAggregation\n                },\n                groupAggregations: {\n                    v0: target.groupAggregation\n                },\n                by: getGroupBy(),\n                configuration: {\n                    groups: []\n                }\n            }\n        };\n    } else {\n        return null;\n    }\n\n    function getTime() {\n        return {\n            from: requestTime.from * 1000000,\n            to: requestTime.to * 1000000,\n            sampling:\n                (target.isSingleDataPoint\n                    ? requestTime.to - requestTime.from\n                    : requestTime.sampling) * 1000000\n        };\n    }\n    function getMetrics() {\n        if (target.isSingleDataPoint) {\n            const metrics = {\n                v0: target.target\n            };\n\n            if (target.segmentBy) {\n                target.segmentBy.forEach((segmentBy, i) => {\n                    metrics[`k${i}`] = segmentBy;\n                });\n            }\n\n            return metrics;\n        } else {\n            const metrics = {\n                k0: 'timestamp',\n                v0: target.target\n            };\n\n            if (target.segmentBy) {\n                target.segmentBy.forEach((segmentBy, i) => {\n                    metrics[`k${i + 1}`] = segmentBy;\n                });\n            }\n\n            return metrics;\n        }\n    }\n\n    function getSort() {\n        const sortDirection = target.sortDirection || 'desc';\n\n        let sort;\n\n        if (target.isTabularFormat === false) {\n            sort = [{ v0: sortDirection }, { k0: sortDirection }];\n\n            if (target.segmentBy) {\n                sort.push({ k1: sortDirection });\n            }\n        } else {\n            // sort table by first label, let Grafana to sort the final table then\n            sort = [{ k0: sortDirection }];\n        }\n\n        return sort;\n    }\n\n    function getPaging() {\n        return {\n            from: 0,\n            to: (target.pageLimit || 10) - 1\n        };\n    }\n\n    function getGroupBy() {\n        if (target.isSingleDataPoint) {\n            const groupBy = [];\n\n            if (target.segmentBy) {\n                target.segmentBy.forEach((segmentBy, i) => {\n                    groupBy.push({\n                        metric: `k${i}`\n                    });\n                });\n            }\n\n            return groupBy;\n        } else {\n            const groupBy = [\n                {\n                    metric: 'k0',\n                    value: requestTime.sampling * 1000000\n                }\n            ];\n\n            if (target.segmentBy) {\n                target.segmentBy.forEach((segmentBy, i) => {\n                    groupBy.push({\n                        metric: `k${i + 1}`\n                    });\n                });\n            }\n\n            return groupBy;\n        }\n    }\n}\n\nfunction parseResponses(options, response) {\n    const isTabularFormat = options.targets[0].isTabularFormat;\n    const isSingleTarget = options.targets.length === 1;\n    const data = options.targets.map((target, i) => {\n        const isSingleDataPoint = target.isSingleDataPoint;\n\n        if (response[i].data) {\n            const map = response[i].data.reduce((acc, d) => {\n                const keys = response[i].group.by\n                    .map((group) => group['metric'])\n                    // assume timestamp is always the first one, ie. k0\n                    .slice(isSingleDataPoint ? 0 : 1);\n\n                let t;\n                if (target.segmentBy) {\n                    const segmentNames = keys\n                        .map((segment) => FormatterService.formatLabelValue(d[segment]))\n                        .join(' - ');\n\n                    if (isTabularFormat || isSingleTarget) {\n                        t = segmentNames;\n                    } else {\n                        t = `${FormatterService.formatLabelValue(target.target)} (${segmentNames})`;\n                    }\n                } else {\n                    t = FormatterService.formatLabelValue(target.target);\n                }\n\n                if (acc[t] === undefined) {\n                    acc[t] = {\n                        target: t,\n                        datapoints: []\n                    };\n                }\n\n                if (isTabularFormat) {\n                    acc[t].datapoints.push([\n                        ...keys.map((key) => d[key]),\n                        d.v0,\n                        response[i].time.from\n                    ]);\n                } else if (isSingleDataPoint) {\n                    acc[t].datapoints.push([d.v0, response[i].time.from]);\n                } else {\n                    acc[t].datapoints.push([d.v0, d.k0 / 1000]);\n                }\n\n                return acc;\n            }, {});\n\n            if (isSingleDataPoint) {\n                return Object.values(map).sort((a, b) => {\n                    if (a.datapoints[0][0] === b.datapoints[0][0]) {\n                        return a.target.localeCompare(b.target);\n                    } else {\n                        if (target.sortDirection === 'desc') {\n                            return b.datapoints[0][0] - a.datapoints[0][0];\n                        } else {\n                            return a.datapoints[0][0] - b.datapoints[0][0];\n                        }\n                    }\n                });\n            } else {\n                return Object.values(map).sort((a, b) => a.target.localeCompare(b.target));\n            }\n        } else {\n            return {\n                target: target.target,\n                error: response[i].errors[0]\n            };\n        }\n    });\n\n    if (isTabularFormat && data.length > 0) {\n        const failures = data.filter((d) => d.error);\n        if (failures.length > 0) {\n            return { data: failures };\n        }\n\n        const targetsDataset = data[0];\n        const segments = options.targets[0].segmentBy;\n        const metrics = options.targets.map((target) => target.target);\n\n        const tabularDataset = Object.assign({}, targetsDataset, {\n            type: 'table',\n            columns: [\n                ...segments.map((segmentBy) => ({ text: segmentBy })),\n                ...metrics.map((metric) => ({ text: metric }))\n            ],\n            rows: targetsDataset.map((referenceRow, i) => {\n                const referenceData = referenceRow.datapoints[0];\n\n                return [\n                    ...referenceData.slice(0, segments.length),\n                    referenceData[segments.length],\n                    ...data.slice(1).map((d) => {\n                        if (d[i].target === referenceRow.target) {\n                            return d[i].datapoints[0][segments.length];\n                        } else {\n                            // datasets could have different sets of segments; currently, no merge is performed\n                            return null;\n                        }\n                    })\n                ];\n            })\n        });\n\n        return {\n            data: [Object.assign({}, data[0], tabularDataset)]\n        };\n    } else {\n        return {\n            data: _.flatten(data)\n        };\n    }\n}\n"]}